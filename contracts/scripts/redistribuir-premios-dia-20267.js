const { ethers } = require("hardhat");

// CONTRATO V6 ACTUAL
const CONTRACT_ADDRESS = "0xDAf05A87D1C2Dd6d00f6b9fd9Af4A80d818D1e61";
const DIA_A_REDISTRIBUIR = 20267;

async function main() {
    console.log("üîÑ REDISTRIBUCI√ìN DE PREMIOS D√çA 20267");
    console.log("=".repeat(60));
    console.log("üìç Contrato V6:", CONTRACT_ADDRESS);
    console.log("üìÖ D√≠a a redistribuir:", DIA_A_REDISTRIBUIR);
    
    const [deployer] = await ethers.getSigners();
    console.log("üë§ Ejecutando como:", deployer.address);
    
    try {
        // Conectar al contrato
        const LottoMojiCore = await ethers.getContractFactory("LottoMojiCore");
        const contract = LottoMojiCore.attach(CONTRACT_ADDRESS);
        
        // ==========================================
        // 1. VERIFICAR ESTADO ACTUAL
        // ==========================================
        console.log("\nüìä 1. ESTADO ACTUAL DEL D√çA", DIA_A_REDISTRIBUIR);
        console.log("-".repeat(40));
        
        const [dailyPoolInfo, mainPools, reservePools] = await Promise.all([
            contract.getDailyPoolInfo(DIA_A_REDISTRIBUIR),
            contract.getMainPoolBalances(),
            contract.getReservePoolBalances()
        ]);
        
        const formatUSDC = (amount) => (Number(amount) / 1e6).toFixed(6);
        
        console.log("üéØ Ya sorteado:", dailyPoolInfo.drawn);
        console.log("üì¶ Ya distribuido:", dailyPoolInfo.distributed);
        console.log("üî¢ N√∫meros ganadores:", dailyPoolInfo.winningNumbers.map(n => Number(n)));
        console.log("üí∞ Total recolectado:", formatUSDC(dailyPoolInfo.totalCollected), "USDC");
        
        console.log("\nüèÜ POOLS PRINCIPALES:");
        console.log("ü•á Primer Premio:", formatUSDC(mainPools.firstPrizeAccumulated), "USDC");
        console.log("ü•à Segundo Premio:", formatUSDC(mainPools.secondPrizeAccumulated), "USDC");
        console.log("ü•â Tercer Premio:", formatUSDC(mainPools.thirdPrizeAccumulated), "USDC");
        console.log("üíº Desarrollo:", formatUSDC(mainPools.developmentAccumulated), "USDC");
        
        console.log("\nüè¶ POOLS DE RESERVA:");
        console.log("üîí Reserva Principal:", formatUSDC(reservePools.mainReserve), "USDC");
        console.log("üîí Reserva Secundaria:", formatUSDC(reservePools.secondaryReserve), "USDC");
        
        // ==========================================
        // 2. VERIFICAR SI SE PUEDE REDISTRIBUIR
        // ==========================================
        console.log("\nüîç 2. VERIFICANDO POSIBILIDAD DE REDISTRIBUCI√ìN");
        console.log("-".repeat(40));
        
        if (!dailyPoolInfo.drawn) {
            console.log("‚ùå ERROR: El d√≠a no ha sido sorteado a√∫n");
            console.log("üí° Primero se debe ejecutar el sorteo");
            return;
        }
        
        if (!dailyPoolInfo.distributed) {
            console.log("‚ö†Ô∏è El d√≠a est√° sorteado pero NO distribuido");
            console.log("üöÄ Se puede ejecutar la distribuci√≥n por primera vez");
        } else {
            console.log("‚úÖ El d√≠a ya est√° distribuido");
            console.log("üîÑ Se puede intentar redistribuci√≥n forzada");
        }
        
        // ==========================================
        // 3. OBTENER INFORMACI√ìN DE GANADORES
        // ==========================================
        console.log("\nüèÜ 3. AN√ÅLISIS DE GANADORES");
        console.log("-".repeat(40));
        
        const totalTickets = Number(dailyPoolInfo.totalTickets);
        console.log("üé´ Total tickets del d√≠a:", totalTickets);
        
        if (totalTickets === 0) {
            console.log("‚ùå No hay tickets para este d√≠a");
            return;
        }
        
        // Obtener tickets del d√≠a para contar ganadores
        const ticketsDelDia = await contract.getGameDayTickets(DIA_A_REDISTRIBUIR);
        console.log("üìä Tickets obtenidos:", ticketsDelDia.length);
        
        let conteoGanadores = {
            primerPremio: 0,
            segundoPremio: 0,
            tercerPremio: 0,
            ticketsGratis: 0
        };
        
        const numerosGanadores = dailyPoolInfo.winningNumbers.map(n => Number(n));
        console.log("üé≤ Verificando contra n√∫meros:", numerosGanadores);
        
        // Contar ganadores (muestra de primeros 50 tickets para no saturar)
        const muestra = Math.min(50, ticketsDelDia.length);
        console.log(`üîç Analizando muestra de ${muestra} tickets...`);
        
        for (let i = 0; i < muestra; i++) {
            try {
                const ticketInfo = await contract.getFullTicketInfo(ticketsDelDia[i]);
                const resultado = verificarTicket(
                    ticketInfo.numbers.map(n => Number(n)), 
                    numerosGanadores
                );
                
                switch (resultado.tipo) {
                    case 'PRIMER_PREMIO':
                        conteoGanadores.primerPremio++;
                        console.log(`   ü•á Ticket #${ticketsDelDia[i]}: [${ticketInfo.numbers.map(n => Number(n)).join(', ')}]`);
                        break;
                    case 'SEGUNDO_PREMIO':
                        conteoGanadores.segundoPremio++;
                        console.log(`   ü•à Ticket #${ticketsDelDia[i]}: [${ticketInfo.numbers.map(n => Number(n)).join(', ')}]`);
                        break;
                    case 'TERCER_PREMIO':
                        conteoGanadores.tercerPremio++;
                        break;
                    case 'TICKETS_GRATIS':
                        conteoGanadores.ticketsGratis++;
                        break;
                }
            } catch (error) {
                // Continuar con el siguiente ticket
            }
        }
        
        console.log("\nüìä GANADORES EN MUESTRA:");
        console.log("ü•á Primer Premio:", conteoGanadores.primerPremio);
        console.log("ü•à Segundo Premio:", conteoGanadores.segundoPremio);
        console.log("ü•â Tercer Premio:", conteoGanadores.tercerPremio);
        console.log("üé´ Tickets Gratis:", conteoGanadores.ticketsGratis);
        
        // ==========================================
        // 4. OPCIONES DE REDISTRIBUCI√ìN
        // ==========================================
        console.log("\nüîÑ 4. OPCIONES DE REDISTRIBUCI√ìN");
        console.log("-".repeat(40));
        
        console.log("üõ†Ô∏è FUNCIONES DISPONIBLES:");
        
        // Verificar si hay funci√≥n de redistribuci√≥n forzada
        try {
            // Intentar ver si existe la funci√≥n forceDistribution
            const hasForceDistribution = await contract.interface.getFunction("forceDistribution");
            console.log("‚úÖ forceDistribution() disponible");
        } catch {
            console.log("‚ùå forceDistribution() no disponible");
        }
        
        try {
            // Intentar ver si existe la funci√≥n distributePrizes
            const hasDistributePrizes = await contract.interface.getFunction("distributePrizes");
            console.log("‚úÖ distributePrizes() disponible");
        } catch {
            console.log("‚ùå distributePrizes() no disponible");
        }
        
        try {
            // Intentar ver si existe la funci√≥n redistributeDay
            const hasRedistributeDay = await contract.interface.getFunction("redistributeDay");
            console.log("‚úÖ redistributeDay() disponible");
        } catch {
            console.log("‚ùå redistributeDay() no disponible");
        }
        
        // ==========================================
        // 5. EJECUTAR REDISTRIBUCI√ìN
        // ==========================================
        console.log("\nüöÄ 5. EJECUTANDO REDISTRIBUCI√ìN");
        console.log("-".repeat(40));
        
        // Estrategia: Intentar diferentes m√©todos de redistribuci√≥n
        let redistribucionExitosa = false;
        
        // M√©todo 1: forceDistribution si existe
        if (!redistribucionExitosa) {
            try {
                console.log("üîÑ Intentando forceDistribution()...");
                const tx = await contract.forceDistribution(DIA_A_REDISTRIBUIR);
                console.log("üìù Hash de transacci√≥n:", tx.hash);
                console.log("‚è≥ Esperando confirmaci√≥n...");
                await tx.wait();
                console.log("‚úÖ forceDistribution() ejecutada exitosamente");
                redistribucionExitosa = true;
            } catch (error) {
                console.log("‚ùå forceDistribution() fall√≥:", error.message);
            }
        }
        
        // M√©todo 2: distributePrizes si existe
        if (!redistribucionExitosa) {
            try {
                console.log("üîÑ Intentando distributePrizes()...");
                const tx = await contract.distributePrizes(DIA_A_REDISTRIBUIR);
                console.log("üìù Hash de transacci√≥n:", tx.hash);
                console.log("‚è≥ Esperando confirmaci√≥n...");
                await tx.wait();
                console.log("‚úÖ distributePrizes() ejecutada exitosamente");
                redistribucionExitosa = true;
            } catch (error) {
                console.log("‚ùå distributePrizes() fall√≥:", error.message);
            }
        }
        
        // M√©todo 3: redistributeDay si existe
        if (!redistribucionExitosa) {
            try {
                console.log("üîÑ Intentando redistributeDay()...");
                const tx = await contract.redistributeDay(DIA_A_REDISTRIBUIR);
                console.log("üìù Hash de transacci√≥n:", tx.hash);
                console.log("‚è≥ Esperando confirmaci√≥n...");
                await tx.wait();
                console.log("‚úÖ redistributeDay() ejecutada exitosamente");
                redistribucionExitosa = true;
            } catch (error) {
                console.log("‚ùå redistributeDay() fall√≥:", error.message);
            }
        }
        
        // M√©todo 4: Intentar performUpkeep si nada m√°s funciona
        if (!redistribucionExitosa) {
            try {
                console.log("üîÑ Intentando performUpkeep() como √∫ltimo recurso...");
                const upkeepNeeded = await contract.checkUpkeep("0x");
                if (upkeepNeeded[0]) {
                    const tx = await contract.performUpkeep("0x");
                    console.log("üìù Hash de transacci√≥n:", tx.hash);
                    console.log("‚è≥ Esperando confirmaci√≥n...");
                    await tx.wait();
                    console.log("‚úÖ performUpkeep() ejecutado");
                    redistribucionExitosa = true;
                } else {
                    console.log("‚ùå No se necesita upkeep en este momento");
                }
            } catch (error) {
                console.log("‚ùå performUpkeep() fall√≥:", error.message);
            }
        }
        
        // ==========================================
        // 6. VERIFICAR RESULTADO
        // ==========================================
        if (redistribucionExitosa) {
            console.log("\n‚úÖ 6. VERIFICANDO RESULTADO DE REDISTRIBUCI√ìN");
            console.log("-".repeat(40));
            
            // Esperar un poco para que se procesen los cambios
            console.log("‚è≥ Esperando procesamiento...");
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            // Verificar nuevo estado
            const [newDailyPoolInfo, newMainPools] = await Promise.all([
                contract.getDailyPoolInfo(DIA_A_REDISTRIBUIR),
                contract.getMainPoolBalances()
            ]);
            
            console.log("üìä NUEVO ESTADO:");
            console.log("üéØ Ya sorteado:", newDailyPoolInfo.drawn);
            console.log("üì¶ Ya distribuido:", newDailyPoolInfo.distributed);
            console.log("üí∞ Total recolectado:", formatUSDC(newDailyPoolInfo.totalCollected), "USDC");
            
            console.log("\nüèÜ NUEVAS POOLS:");
            console.log("ü•á Primer Premio:", formatUSDC(newMainPools.firstPrizeAccumulated), "USDC");
            console.log("ü•à Segundo Premio:", formatUSDC(newMainPools.secondPrizeAccumulated), "USDC");
            console.log("ü•â Tercer Premio:", formatUSDC(newMainPools.thirdPrizeAccumulated), "USDC");
            
            console.log("\nüéâ ¬°REDISTRIBUCI√ìN COMPLETADA!");
            console.log("üí° Ahora puedes intentar reclamar tus premios");
        } else {
            console.log("\n‚ùå No se pudo ejecutar la redistribuci√≥n");
            console.log("üí° Posibles causas:");
            console.log("   - La distribuci√≥n ya est√° correcta");
            console.log("   - No tienes permisos de administrador");
            console.log("   - Las funciones no est√°n disponibles en este contrato");
            console.log("   - El d√≠a ya fue correctamente distribuido");
        }
        
        console.log("\n" + "=".repeat(60));
        
    } catch (error) {
        console.error("‚ùå Error en la redistribuci√≥n:", error.message);
        console.log("\nüí° SUGERENCIAS:");
        console.log("1. Verifica que tengas permisos de administrador");
        console.log("2. El contrato podr√≠a no permitir redistribuciones");
        console.log("3. Intenta reclamar los premios directamente");
    }
}

// Funci√≥n para verificar un ticket individual
function verificarTicket(ticketNumbers, winningNumbers) {
    // Contar coincidencias exactas (posici√≥n)
    let exactMatches = 0;
    for (let i = 0; i < 4; i++) {
        if (ticketNumbers[i] === winningNumbers[i]) {
            exactMatches++;
        }
    }
    
    // Contar coincidencias totales (cualquier posici√≥n)
    let totalMatches = 0;
    for (let num of ticketNumbers) {
        if (winningNumbers.includes(num)) {
            totalMatches++;
        }
    }
    
    // Determinar tipo de premio seg√∫n l√≥gica V6
    if (exactMatches === 4) {
        return { tipo: 'PRIMER_PREMIO' };
    } else if (totalMatches === 4) {
        return { tipo: 'SEGUNDO_PREMIO' };
    } else if (exactMatches === 3) {
        return { tipo: 'TERCER_PREMIO' };
    } else if (totalMatches >= 3) {
        return { tipo: 'TICKETS_GRATIS' };
    } else {
        return { tipo: 'SIN_PREMIO' };
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });